Title: 競プロ Practice 日記
Date: 2020-04-14
Category: Tech
Tags: AtCoder, ABC, 競技プログラミング
Slug: practice_2020414
Authors: s.hosoya

今日チャレンジした問題  

[A - Shik and Stone](https://atcoder.jp/contests/agc007/tasks/agc007_a)  

パッと見 dfs に見せかけて、じつはdfsだとちょっと難しくて、問題文をちゃんと正しく解釈すれば1行で解けたパターン。  
パッと見であ！dfsだ！チャレンジで見たやつだ！となって意気揚々と実装してみたものの、例１、例２までは通したら例３で見事にハマった。ここで引っかかるところも含めての問題なんだなぁ。。  

dfs に見せかけというのは、ようするに「右」と「下」の移動だけで左上から右下まで # を辿ってゴールにいけるか？という問題に見えたということ。  
この条件で実装すると、例３は `Possible` だが出力例は `Impossible` でええ？となる。  
例３は「右」と「下」の移動だけでゴールまでたどり着けるが、実はこれは題意を満たさない。  


条件は `移動する過程で、駒が常に右または下に動いていた可能性があるか判定してください。` なので、  
移動ルートの中で *左に移動することが可能であったならば*、答えは `Impossible` になる、ということ。  
えー、それって答えが Possible/Impossible なのひっかけすぎない？とは思うけど。。  

上記の条件なので、 dfs で解こうとした場合、ゴールにたどり着くルートを覚えておいて、途中経過で左や上にいくパターンがあったら `Impossible` としないといけないので、単純なdfsよりかなりしんどい、というか自分には実装できなかった。  

で、どうやって解けばよいかというと、実は題意より、  
「入力された `#` の数が、ゴールに辿り着く最短経路の数より多ければ `Impposible` で良い」となる。  
つまり、右か下のみの移動であればかならず最短数でのゴールになるので、それ以上に `#` の数が多かったら `Impposible` でOKということ。はー、なるほど。  

提出: [提出 #11925884](https://atcoder.jp/contests/agc007/submissions/11925884)

```a.py
H,W = map(int,input().split())
c = 0
for _ in range(H):
    c += input().count("#")
 
# #の数が最低限必要な数より多いとImpossibleとなる
print ("Impossible") if c > H+W-1 else print ("Possible")
```
元のマップを記憶する必要もなくて、入力中の `#` をカウントして題意を満たす解を出力するだけ。  
